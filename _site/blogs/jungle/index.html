<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>jungle | papichulo16</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  
</head>
<body>
  <nav class="navbar">
    <a class="menu home-link" href="https://github.com/papichulo16"><img src="/assets/img/chavo.png" alt="gh pfp" class="pfp-img">GitHub</a>

    <div class="nav-right">
      <a href="/">Home</a>
      <a href="/contact">Contact</a>
      <a href="/reviews">Reviews</a>
      <a href="/blogs">Blogs</a>
      <div class="dropdown">
        <span><a href="/projects">Projects ▾</a></span>
        <div class="dropdown-content">
          
            <a href="/projects/1_magical_kernel.html">Magical Kernel (blogs)</a>
          
            <a href="/projects/3_ctf_writeups.html">PWN Writeups (blogs)</a>
          
            <a href="/projects/4_crap.html">C.R.A.P</a>
          
        </div>
      </div>
    </div>
  </nav>
  <hr>

  <main>
    <article class="blog-post">
  <h1>jungle</h1>
  <p class="post-date">October 21, 2024</p>

  <div class="post-content">
    <p><a href="https://github.com/papichulo16/ctf-stuff/tree/main/SunshineCTF/jungle/">source</a></p>

<p>This challenge was really fun. Ran through some trouble at the end but I learned from it.</p>

<p>So this challenge is a tcache exploitation challenge where you can only have up to 6 allocated chunks at the same time. The bug is found with the fact that there are two arrays: one for holding chunk pointers and one with a bunch of boolean values that state whether or not the chunk is in use. This allows for the <code class="language-plaintext highlighter-rouge">remove()</code> function to have some interesting functionality where you can call it twice on the same chunk and it will allow for a UAF since the second time you call it, the chunk will not be freed again, but in fact the program will flip the <code class="language-plaintext highlighter-rouge">in_use</code> variable for the corresponding chunk to <code class="language-plaintext highlighter-rouge">true</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">uint</span> <span class="n">param_1</span><span class="p">)</span>

<span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">knapsack</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
     <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">used</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"&lt;&lt;&lt; Pocket %d is already empty.</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">param_1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)(</span><span class="n">knapsack</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span> <span class="o">*</span> <span class="mi">8</span><span class="p">));</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"&lt;&lt;&lt; Removed item from pocket %d.</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">param_1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="o">*</span><span class="p">(</span><span class="n">uint</span> <span class="o">*</span><span class="p">)(</span><span class="n">used</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> 
    <span class="p">(</span><span class="n">uint</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="n">used</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span><span class="n">param_1</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="o">&lt;===</span> <span class="n">this</span> <span class="n">line</span> <span class="n">is</span> <span class="n">the</span> <span class="n">bug</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this, we can create a tcache poisoning attack. Here is the exploit strategy.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PLAN:
         - freeing twice allows for UAF
         - get heap leak through UAF
         - use genie for libc leak
         - get stack leak through environ
         - ret2libc!!
</code></pre></div></div>

<p>The rest you can see through my exploit, just know that when creating a chunk, the first <code class="language-plaintext highlighter-rouge">0x18</code> bytes will be set to null so that is why my environ leak is a little far back.</p>

<p>Another thing was that my local exploit worked locally but not remotely, and I really struggled on figuring out why. Spent over an hour trying to figure out why but nothing. It wasn’t until I got my friend (the man, the myth, the legend) <a href="https://github.com/SolarDebris">Alex</a> that he saw that I was handling IO not very carefully. This caused the remote version (where things will take a little longer to send/recieve) to not work. So lesson learned, be more careful taking care of IO.</p>


  </div>
</article>

<style>
.blog-post {
  max-width: 800px;
  margin: auto;
  padding: 20px;
}
.post-date {
  color: #777;
  font-size: 0.9rem;
  margin-bottom: 20px;
}
.post-content img {
  max-width: 100%;
}
</style>


  </main>

  <footer>
    <hr>
    © 2025 papichulo16
  </footer>
</body>
</html>

